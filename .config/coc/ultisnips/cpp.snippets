# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
snippet cpt "competitive programming template" b
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef vector<int> vi; // int vec
typedef vector<vi> vvi; // int vec vec
typedef vector<pii> vpi; // int int pair vec

#define d(x) cout << #x << " = " << x << endl;
#define ios ios_base::sync_with_stdio(0), cin.tie(0);
#define forn(i, n) for (int i=0; i< (int)n; ++i)
#define forab(i, a, b) for (int i=a; i< (int)b; ++i)
#define fored(i,l,r) for(int i=(int)r; i>= (int)l; --i)
#define foreach(a, b) for (auto&(a) : (b))
#define formap(map) for (const auto &[key, value] : map)
#define all(v) v.begin(), v.end()
#define allar(arr, sz) arr, arr + sz
#define ms(ar, val) memset(ar, val, size)
#define pq(type) priority_queue<type>
#define pqd(type) priority_queue<type,vector<type>,greater<type> >
#define umap unordered_map
#define uset unordered_set
#define imax INT_MAX
#define imin INT_MIN
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define nl "\n"
#define in(t) while (t--)

const double pi = acos(-1);
const int maxn = 1e5 + 5;
const ll MOD = 1e9 + 7;
const ll INF = 1e9;
const ll INFLL = 1000000000000000005LL;
const ld EPS = 1e-9;
int dirx[8] = { -1, 0, 0, 1, -1, -1, 1, 1 };
int diry[8] = { 0, 1, -1, 0, -1, 1, -1, 1 };

// snippets
// hash: hash used for pairs used in unordered maps
// comp: comparator of pairs used for priority queues
// _ncrmod: choose function for big numbers using modulo
// _ncr: choose function
// _nprmod: permutation function for big numbers using modulo
// _npr: permutation function
// sieve: sieve of eratosthenes

int main() {
  ios
  cout << setprecision(20)<< fixed;
  ${0:${VISUAL}}
}
endsnippet

snippet hash "hash used for pairs used in unorederd maps" b
// unordered_map<pair<int,int>, other_type, HASH> m;
struct HASH{
 size_t operator()(const pair<int,int>&x)const{
  return hash<long long>()(((long long)x.first)^(((long long)x.second)<<32));
 }
};
endsnippet

snippet comp "comparator of pairs used for priority queues" b
// priority_queue<pair<int,int>, vector<pair<int,int>>, Comparator> pq;
struct Comparator {
  constexpr bool operator()(
      pair<int, int> const& a,
      pair<int, int> const& b)
      const noexcept
  {
      return a.second < b.second;
  }
};
endsnippet

snippet _ncrmod "choose function for big numbers using modulo" b
ll inv(ll num, int mod) {
  ll pow = mod - 2;
  ll res = 1;
  while (pow) {
    if (pow % 2 == 1) {
      res *= num;
      res %= mod;
    }
    num *= num;
    num %= mod;
    pow /= 2;
  }
  return res;
}
 
ll ncrmod(ll n, ll r, vector<int> &fact, int mod = MOD) {
  ll total = fact[n] % mod;
  total *= inv(fact[r], mod) % mod;
  total %= mod;
  total *= inv(fact[n - r], mod) % mod;
  total %= mod;
  return total;
}
endsnippet

snippet _ncr "choose function" b
ll ncrmod(ll n, ll r, vector<int> &fact) {
  ll total = fact[n];
  total /= fact[n - r];
  total /= fact[r];
  return total;
}
endsnippet

snippet _nprmod "permutation function for big numbers using modulo" b
ll inv(ll num, int mod) {
  ll pow = mod - 2;
  ll res = 1;
  while (pow) {
    if (pow % 2 == 1) {
      res *= num;
      res %= mod;
    }
    num *= num;
    num %= mod;
    pow /= 2;
  }
  return res;
}
 
ll nprmod(ll n, ll r, vector<int> &fact, int mod = MOD) {
  ll total = fact[n] % mod;
  total *= inv(fact[r], mod) % mod;
  total %= mod;
  return total;
}
endsnippet

snippet _npr "permuation function" b
ll ncrmod(ll n, ll r, vector<int> &fact) {
  ll total = fact[n];
  total /= fact[r];
  return total;
}
endsnippet

snippet sieve "sieve of eratosthenes" b
 vector<bool> seen(4e4 + 1, false);
 vector<int> primes;
 for (int i = 2; i < seen.size(); ++i) {
   if (!seen[i]) {
     primes.push_back(i);
     for (int j = 2 * i; j < seen.size(); j += i)
       seen[j] = true;
   }
 }
endsnippet
